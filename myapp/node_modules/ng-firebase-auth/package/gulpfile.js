'use strict';

// Development versions are default
global.isProd = false;

// Current working directory
var cwd = process.cwd();

var runSequence = require('run-sequence');

// Gulp & Plugins
var gulp = require('gulp');
var $ = require('gulp-load-plugins')();

var concat = $.concat;
var templateCache = $.angularTemplatecache;

// Styles
var sass = require('gulp-sass');
var minifycss = require('gulp-minify-css');

// Scripts
var jshint = require('gulp-jshint');
var browserify = require('browserify');
var stylish = require('jshint-stylish');
var source = require('vinyl-source-stream');
var ngannotate = require('browserify-ngannotate');

// Testing
var karma = require('karma');
var protractor = require('gulp-protractor').protractor;
var webdriver = require('gulp-protractor').webdriver;
var webdriverUpdate = require('gulp-protractor').webdriver_update;

// Dev Server
var superstatic = require('superstatic');

gulp.task('webdriver-update', webdriverUpdate);
gulp.task('webdriver', webdriver);


gulp.task('jshint', function() {
  return gulp.src('./src/**/*.js')
    .pipe(jshint())
    .pipe(jshint.reporter(stylish));
});

gulp.task('styles', function() {
  return gulp.src('testapp/styles/main.scss')
    .pipe(sass({
      sourceComments: global.isProd ? 'none' : 'map',
      sourceMap: 'sass',
      outputStyle: global.isProd ? 'compressed' : 'nested'
    }))
    .pipe($.if(global.isProd, minifycss()))
    .pipe(gulp.dest('testapp'));
});

gulp.task('build-module', ['jshint'], function() {
  return browserify({
    entries: ['./src/main.js'],
    debug: global.isProd ? false : true,
    insertGlobals: true,
    transform: ngannotate
  })
  .bundle()
  .pipe(source('ng-firebase-auth.js'))
  .pipe(gulp.dest('testapp'))
  .pipe(gulp.dest('dist'))
  .pipe($.if(global.isProd, $.rename('ng-firebase-auth.min.js')))
  .pipe($.if(global.isProd, $.streamify($.uglify())))
  .pipe(gulp.dest('dist'));
});

gulp.task('build-testapp', function() {
  return browserify({
    entries: ['./testapp/scripts/main.js'],
    debug: true,
    insertGlobals: true,
    transform: ngannotate
  })
  .bundle()
  .pipe(source('bundle.js'))
  .pipe(gulp.dest('testapp'));
});

gulp.task('test', function(done) {
  return karma.server.start({
    configFile: cwd + '/karma.conf.js'
  }, done);
});

gulp.task('protractor', ['webdriver-update', 'webdriver' ], function() {
  return gulp.src('test/e2e/**/*.js')
    .pipe(protractor({
        configFile: './protractor.conf.js',
    }))
    .on('error', function(err) {
      // Make sure failed tests cause gulp to exit non-zero
      throw err;
    });
});

gulp.task('watch', function() {
  gulp.watch('src/**/*.js', ['build-testapp']);
  gulp.watch('testapp/scripts/**/*.js', ['build-testapp']);
  return gulp.watch('testapp/styles/**/*.scss', ['styles']);
});

gulp.task('server', function(next) {
  var server = superstatic({
    logger: {
      info: function(msg) {
        console.log('Info:', msg);
      },
      error: function(msg) {
        console.error('Error:', msg);
      }
    },
    port: 4000,
    config: 'divshot.json'
  });
  server.listen(function() {
    console.log('Server running on port ' + server.port);
  });
  next();
});

gulp.task('prod', function() {
  global.isProd = true;
  return runSequence('build-module');
});

gulp.task('build', function() {
  return runSequence('build-module', 'build-testapp', 'styles');
});

gulp.task('default', function() {
  return runSequence('build', 'watch', 'server');
});
